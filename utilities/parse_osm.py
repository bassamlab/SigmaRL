import xml.etree.ElementTree as ET
import torch
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator

import os
import sys
script_dir = os.path.dirname(__file__) # Directory of the current script
project_root = os.path.dirname(script_dir) # Project root directory
if project_root not in sys.path:
    sys.path.append(project_root)
    
from utilities.parse_map_base import ParseMapBase

from utilities.colors import Color

class ParseOSM(ParseMapBase):
    """
    ParseOSM is a class to parse OSM files generated by JOSM software (https://josm.openstreetmap.de/), which provides coordinates of center lines in GPS system without left and right boundaries.
    Therefore, this class also provides function to calculate left and right boundaries of the given center lines and the given lane width.
    
    The longitudinal coordinates correspond to x coordinates, and lateral coordinates correspond to y coordinates. They will be simply scaled by a given factor `scale`.
    """
    def __init__(self, map_path, device, scale, width, reference_paths_ids, **kwargs):
        super().__init__(map_path, device, **kwargs)  # Initialize base class
        
        self._width = width  # Width of the lane
        self._scale = scale  # Scale of the map
        self._reference_paths_ids = reference_paths_ids  # IDs of lanes that build the reference paths

        self._nodes = {}
        self._ways = {}
        
        self._parse_map_file()
        self._process_map_data()
        self._get_reference_paths()
        
        if self._is_visualize_map:
            self.visualize_map()

    def _parse_map_file(self):
        """Parse the OSM file and extract bounds, nodes, and ways."""
        tree = ET.parse(self._map_path)
        root = tree.getroot()

        # Extract nodes
        node_data = {}
        for node in root.findall('node'):
            node_id = int(node.get('id'))
            lat = float(node.get('lat'))
            lon = float(node.get('lon'))
            node_data[node_id] = (lat, lon)

            # Update bounds
            if lat < self.bounds['min_x']:
                self.bounds['min_x'] = lat
            if lon < self.bounds['min_y']:
                self.bounds['min_y'] = lon
            if lat > self.bounds['max_x']:
                self.bounds['max_x'] = lat
            if lon > self.bounds['max_y']:
                self.bounds['max_y'] = lon

        # Scale and shift nodes
        for node_id, (lat, lon) in node_data.items():
            lat = (lat - self.bounds['min_x']) * self._scale + self._width * 1.2  # Plus a small margin to to ensure the coordinates of left and right boundaries will still be positive
            lon = (lon - self.bounds['min_y']) * self._scale + self._width * 1.2
            self._nodes[node_id] = (lat, lon)

        # Extract ways
        for way in root.findall('way'):
            way_id = int(way.get('id'))
            node_refs = [int(nd.get('ref')) for nd in way.findall('nd')]
            tag = way.find("tag[@k='lanes']")
            lanes = int(tag.get('v')) if tag is not None else None
            self._ways[way_id] = {'nodes': node_refs, 'lanes': lanes}


    def _process_map_data(self):
        map_data_tmp = []
        """Calculate the relevant data for each center line and store them in self.lanelets_all."""
        for way_id, way in self._ways.items():
            center_line_points = [self._nodes[node_id] for node_id in way['nodes']]
            center_line = torch.tensor(center_line_points, device=self._device, dtype=torch.float32)
            center_line_yaw, center_line_vec_normalized, center_line_vec_mean_length = self._compute_center_line_info(center_line)
            left_boundary, right_boundary = self._compute_boundaries(center_line)
            
            map_data_tmp.append(
                {
                    str(way["lanes"]): {
                        'center_line': center_line,
                        'center_line_yaw': center_line_yaw,
                        'center_line_vec_normalized': center_line_vec_normalized,
                        'center_line_vec_mean_length': center_line_vec_mean_length,
                        'left_boundary': left_boundary,
                        'right_boundary': right_boundary,
                        'left_boundary_shared': left_boundary,  # Should be calculated if they are not the same
                        'right_boundary_shared': right_boundary,  # Should be calculated if they are not the same
                    }
                }
            )

        sorted_list = sorted(map_data_tmp, key=lambda x: next(iter(x)))

        # Extracting the values from the sorted list of dictionaries
        self.lanelets_all = [list(d.values())[0] for d in sorted_list]

    def _get_reference_paths(self):
        """
        Get the reference paths based on reference paths IDs.

        Returns:
            List of dict: Each dict contains information about a reference path.
        """
        for ref_path in self._reference_paths_ids:
            center_line_points = []
    
            # Check if the reference path is a loop
            is_loop = len(ref_path) > 1 and ref_path[0] == ref_path[-1]

            for path_idx in range(len(ref_path)):
                way_id = ref_path[path_idx]

                way_data = self.lanelets_all[way_id - 1]  # Assume way ID starts with 1
                nodes_to_add = way_data['center_line']
                
                if path_idx > 0:  # Avoid repeated nodes, since the first node of one lane overlaps with the last node of its predecessor lane
                    nodes_to_add = nodes_to_add[1:]

                center_line_points.extend(nodes_to_add)

            if is_loop and center_line_points:
                # Delete the last node since it overlaps with the first node in case of a loop-shaped reference path
                center_line_points.pop()

            if center_line_points:
                center_line = torch.stack(center_line_points)
                center_line_yaw, center_line_vec_normalized, center_line_vec_mean_length = self._compute_center_line_info(center_line)
                left_boundary, right_boundary = self._compute_boundaries(center_line)

                self.reference_paths.append({
                    'reference_lanelets': torch.tensor(ref_path, device=self._device, dtype=torch.int32),
                    'center_line': center_line,
                    'center_line_yaw': center_line_yaw,
                    'center_line_vec_normalized': center_line_vec_normalized,
                    'center_line_vec_mean_length': center_line_vec_mean_length,
                    'left_boundary': left_boundary,
                    'right_boundary': right_boundary,
                    'left_boundary_shared': left_boundary,
                    'right_boundary_shared': right_boundary,
                    'is_loop': is_loop,
                })

    def _compute_center_line_info(self, center_line):
        """Compute additional information about the center line."""
        center_line_vec = torch.diff(center_line, dim=0) # Vectors connecting each pair of neighboring points on the center line
        center_line_vec_length = torch.norm(center_line_vec, dim=1) # The lengths of the vectors
        center_line_vec_mean_length = torch.mean(center_line_vec_length) # The mean length of the vectors
        center_line_vec_normalized = center_line_vec / center_line_vec_length.unsqueeze(1)
        
        center_line_yaw = torch.atan2(center_line_vec[:,1], center_line_vec[:,0])
    
        return center_line_yaw, center_line_vec_normalized, center_line_vec_mean_length

    def _compute_boundaries(self, center_line):
        """Compute left and right boundaries of the given center line."""
        def normalize(v):
            norm = torch.norm(v)
            return v if norm == 0 else v / norm

        left_boundary = []
        right_boundary = []

        for i in range(len(center_line) - 1):
            p1 = center_line[i]
            p2 = center_line[i + 1]
            direction = p2 - p1
            perp_direction = torch.tensor([-direction[1], direction[0]])
            perp_direction = normalize(perp_direction)

            left_boundary.append(p1 + perp_direction * self._width / 2)
            right_boundary.append(p1 - perp_direction * self._width / 2)

        left_boundary.append(center_line[-1] + perp_direction * self._width / 2)
        right_boundary.append(center_line[-1] - perp_direction * self._width / 2)

        return torch.stack(left_boundary), torch.stack(right_boundary)

    def visualize_map(self, is_save_fig=True, is_show=False, is_show_an_agent=False):
        """
        Visualize the map.
        """
        
        # Collect all x and y coordinates to determine limits
        all_x = []
        all_y = []

        for path in self.reference_paths:
            center_line = path['center_line']
            left_boundary = path['left_boundary']
            right_boundary = path['right_boundary']

            all_x.extend(center_line[:, 0].tolist())
            all_y.extend(center_line[:, 1].tolist())
            all_x.extend(left_boundary[:, 0].tolist())
            all_y.extend(left_boundary[:, 1].tolist())
            all_x.extend(right_boundary[:, 0].tolist())
            all_y.extend(right_boundary[:, 1].tolist())

        # Determine limits
        x_lim_min = min(all_x)
        x_lim_max = max(all_x)
        y_lim_min = min(all_y)
        y_lim_max = max(all_y)

        # Set up the plot
        plt.figure(figsize=(x_lim_max - x_lim_min, y_lim_max - y_lim_min))  # Size in inches, adjusted for 4.0m x 4.5m dimensions
        plt.axis("equal")  # Ensure x and y dimensions are equally scaled
        plt.grid(True, linewidth=0.3)
        
        for path in self.reference_paths:
            center_line = path['center_line']
            left_boundary = path['left_boundary']
            right_boundary = path['right_boundary']
            center_line_vec_normalized = path['center_line_vec_normalized']


            plt.plot(center_line[:, 0], center_line[:, 1], color = Color.black50, linestyle="--", linewidth=self._linewidth, label='Center Line')
            plt.plot(left_boundary[:, 0], left_boundary[:, 1], color = Color.black50, linestyle="-", linewidth=self._linewidth, label='Left Boundary')
            plt.plot(right_boundary[:, 0], right_boundary[:, 1], color = Color.black50, linestyle="-", linewidth=self._linewidth, label='Right Boundary')
            # Fill the area between boundaries
            curve_close = torch.vstack([left_boundary, right_boundary.flip(0)])
            plt.fill(curve_close[:,0], curve_close[:,1], color="lightgrey", alpha=0.5)
        
            # Add arrows to indicate direction
            p_start = center_line[0]
            direction_start = center_line_vec_normalized[0]
            plt.quiver(p_start[0], p_start[1], direction_start[0], direction_start[1], angles='xy', scale_units='xy', scale=1.5, color='b')
            # Calculate the starting point for the ending arrow
            p_end = center_line[-1]
            direction_end = center_line_vec_normalized[-1]
            arrow_length = 0.65  # Adjust here for your case
            # Starting point for the ending arrow such that it ends at the last point
            p_end_start = p_end - direction_end * arrow_length
            plt.quiver(p_end_start[0], p_end_start[1], direction_end[0], direction_end[1], angles='xy', scale_units='xy', scale=1.5, color='b', alpha=0.2)

        plt.xlim(x_lim_min, x_lim_max)
        plt.ylim(y_lim_min, y_lim_max)
        
        plt.xlabel(r'$x$ [m]')
        plt.ylabel(r'$y$ [m]')
        plt.title('T-Intersection', fontsize=self._fontsize)
        
        # Use MaxNLocator to ensure ticks are at readable intervals
        ax = plt.gca()
        ax.xaxis.set_major_locator(MaxNLocator(integer=False, prune='both', nbins='auto'))
        ax.yaxis.set_major_locator(MaxNLocator(integer=False, prune='both', nbins='auto'))
        
        if self._is_save_fig:
            # Save fig
            plt.tight_layout() # Set the layout to be tight to minimize white space
            plt.savefig(self._file_name + ".pdf", format="pdf", bbox_inches="tight")
            print(f"A fig is saved at {self._file_name + '.pdf'}")
            
        if self._is_plt_show:
            plt.show()

if __name__ == "__main__":
    parser = ParseOSM(
        map_path="assets/maps/T_intersection_1.osm",
        width=0.15,  # [m]
        scale=1e5,
        device="cpu" if not torch.cuda.is_available() else "cuda:0",
        reference_paths_ids=[[1], [2, 3], [2, 7], [4], [5, 6], [8, 6]],
        is_visualize_map=True,
        is_save_fig=True,
        is_plt_show=True,
    )
    
    print(parser.lanelets_all)
    print(parser.reference_paths)
