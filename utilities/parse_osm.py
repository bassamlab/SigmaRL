# Copyright (c) 2024, Chair of Embedded Software (Informatik 11), RWTH Aachen University.
# Licensed under the MIT License. See LICENSE file in the project root for full license information.

import xml.etree.ElementTree as ET
import torch
import matplotlib.pyplot as plt

# Scientific plotting
import scienceplots  # Do not remove (https://github.com/garrettj403/SciencePlots)

plt.rcParams.update(
    {"figure.dpi": "100"}
)  # Avoid DPI problem (https://github.com/garrettj403/SciencePlots/issues/60)
plt.style.use(
    ["science", "ieee", "no-latex"]
)  # The science + ieee styles for IEEE papers (can also be one of 'ieee' and 'science' )
# print(plt.style.available) # List all available style

import os
import sys

script_dir = os.path.dirname(__file__)  # Directory of the current script
project_root = os.path.dirname(script_dir)  # Project root directory
if project_root not in sys.path:
    sys.path.append(project_root)

from utilities.parse_map_base import ParseMapBase

from utilities.colors import Color

from utilities.constants import SCENARIOS


class ParseOSM(ParseMapBase):
    """
    ParseOSM is a class to parse OSM files generated by JOSM software (https://josm.openstreetmap.de/), which provides coordinates of center lines in GPS system without left and right boundaries.
    Therefore, this class also provides function to calculate left and right boundaries of the given center lines and the given lane width.

    There are a few points worth notin:
    - OSM files generated by JOSM store data in earth coordinate system, i.e., longitudinal and lateral coordinates. We map longitudinal coordinates to x coordinates and lateral coordinates to y coordinates. They will be simply scaled by a given factor `scale`.
    - When designing road network in JOSM, please assign each "way" (JOSM calls a lanelet a way) a distinct, integer tag. This servers as ID of the way.
    """

    def __init__(self, scenario_type, device, **kwargs):
        super().__init__(scenario_type, device, **kwargs)  # Initialize base class

        try:
            self._reference_paths_ids = SCENARIOS[scenario_type][
                "reference_paths_ids"
            ]  # A list of lists. Each sub-list stores the IDs of lanelets building a reference path
            self._neighboring_lanelet_ids = SCENARIOS[scenario_type][
                "neighboring_lanelet_ids"
            ]
            self._fig_title = SCENARIOS[scenario_type]["name"]
        except (KeyError):
            raise KeyError(
                f"Scenario '{scenario_type}' does not exist. If you have added new scenarios, please include them in `SCENARIOS` in utilities/constants.py."
            )

        self._nodes = {}
        self._ways = {}

        self._parse_map_file()
        self._process_map_data()
        self._get_reference_paths()
        self._determine_neighboring_lanelets()

        if self._is_visualize_map:
            self._visualize_map()

    def _parse_map_file(self):
        """Parse the OSM file and extract bounds, nodes, and ways."""
        tree = ET.parse(self._map_path)
        root = tree.getroot()

        # Extract nodes
        node_data = {}
        for node in root.findall("node"):
            node_id = int(node.get("id"))
            lat = float(node.get("lat"))
            lon = float(node.get("lon"))
            node_data[node_id] = (lat, lon)

            # Update bounds
            if lat < self.bounds["min_x"]:
                self.bounds["min_x"] = lat
            if lon < self.bounds["min_y"]:
                self.bounds["min_y"] = lon
            if lat > self.bounds["max_x"]:
                self.bounds["max_x"] = lat
            if lon > self.bounds["max_y"]:
                self.bounds["max_y"] = lon

        # Scale and shift nodes
        for node_id, (lat, lon) in node_data.items():
            lat = (
                lat - self.bounds["min_x"]
            ) * self._scale + self._width * 1.2  # Plus a small margin to to ensure the coordinates of left and right boundaries will still be positive
            lon = (lon - self.bounds["min_y"]) * self._scale + self._width * 1.2
            self._nodes[node_id] = (lat, lon)

        # Extract ways
        for way in root.findall("way"):
            way_id = int(way.get("id"))
            node_refs = [int(nd.get("ref")) for nd in way.findall("nd")]
            tag = way.find("tag[@k='lanes']")
            lanes = int(tag.get("v")) if tag is not None else None
            self._ways[way_id] = {"nodes": node_refs, "lanes": lanes}

    def _process_map_data(self):
        """
        Calculate the relevant data for each center line and store them in self.lanelets_all.
        """
        lanelets_all_tmp = []
        self._lanelet_id_to_index = {}  # Dictionary to store the mapping

        for _, way in self._ways.items():
            lanelet_id = way["lanes"]

            if lanelet_id is not None:
                # Only lanelets with IDs will be considered, i.e., only ways in JOSM that have a tag will be considered
                if not isinstance(lanelet_id, int):
                    raise ValueError(
                        "At least one lanelet has non-integer tag. Please check your OSM file."
                    )
                center_line_points = [self._nodes[node_id] for node_id in way["nodes"]]
                center_line = torch.tensor(
                    center_line_points, device=self._device, dtype=torch.float32
                )
                (
                    center_line_yaw,
                    center_line_vec_normalized,
                    center_line_vec_mean_length,
                ) = self._compute_center_line_info(center_line)
                left_boundary, right_boundary = self._compute_boundaries(center_line)

                lanelets_all_tmp.append(
                    {
                        str(lanelet_id): {
                            "center_line": center_line,
                            "center_line_yaw": center_line_yaw,
                            "center_line_vec_normalized": center_line_vec_normalized,
                            "center_line_vec_mean_length": center_line_vec_mean_length,
                            "left_boundary": left_boundary,
                            "right_boundary": right_boundary,
                            "left_boundary_shared": left_boundary,  # Should be calculated if they are not the same
                            "right_boundary_shared": right_boundary,  # Should be calculated if they are not the same
                        }
                    }
                )
            else:
                print(
                    "At least one lanelet does not have a tag. These lanelets will not be considered."
                )

        # sorted_list = sorted(lanelets_all_tmp, key=lambda x: next(iter(x)))

        # Extracting the values from the list of dictionaries
        self.lanelets_all = [list(d.values())[0] for d in lanelets_all_tmp]

        # Creating the mapping from way["lanes"] to the index after sorting
        for index, lanelet_dict in enumerate(lanelets_all_tmp):
            lanelet_id = next(iter(lanelet_dict))
            self._lanelet_id_to_index[lanelet_id] = index

    def _get_reference_paths(self):
        """
        Get the reference paths based on reference paths IDs.

        Returns:
            List of dict: Each dict contains information about a reference path.
        """
        for ref_path_ids in self._reference_paths_ids:

            center_line_points = []

            # Check if the reference path is a loop
            is_loop = len(ref_path_ids) > 1 and ref_path_ids[0] == ref_path_ids[-1]

            for path_idx in range(len(ref_path_ids)):
                way_id = str(ref_path_ids[path_idx])
                way_idx = self._lanelet_id_to_index[way_id]

                way_data = self.lanelets_all[way_idx]
                nodes_to_add = way_data["center_line"]

                if (
                    path_idx > 0
                ):  # Avoid repeated nodes, since the first node of one lane overlaps with the last node of its predecessor lane
                    nodes_to_add = nodes_to_add[1:]

                center_line_points.extend(nodes_to_add)

            if is_loop and center_line_points:
                # Delete the last node since it overlaps with the first node in case of a loop-shaped reference path
                center_line_points.pop()

            if center_line_points:
                center_line = torch.stack(center_line_points)
                (
                    center_line_yaw,
                    center_line_vec_normalized,
                    center_line_vec_mean_length,
                ) = self._compute_center_line_info(center_line)
                left_boundary, right_boundary = self._compute_boundaries(center_line)

                self.reference_paths.append(
                    {
                        "lanelet_IDs": ref_path_ids,
                        "center_line": center_line,
                        "center_line_yaw": center_line_yaw,
                        "center_line_vec_normalized": center_line_vec_normalized,
                        "center_line_vec_mean_length": center_line_vec_mean_length,
                        "left_boundary": left_boundary,
                        "right_boundary": right_boundary,
                        "left_boundary_shared": left_boundary,
                        "right_boundary_shared": right_boundary,
                        "is_loop": is_loop,
                    }
                )

    def _determine_neighboring_lanelets(self):
        # Map from lanelet IDs to indices
        neighboring_lanelets_idx_dict = {
            lanelet_id: [
                self._lanelet_id_to_index[neighbor_id] for neighbor_id in neighbor_list
            ]
            for lanelet_id, neighbor_list in self._neighboring_lanelet_ids.items()
        }

        # Sort the keys in `neighboring_lanelets_idx_dict` based on `self._lanelet_id_to_index`
        self.neighboring_lanelets_idx = [
            neighboring_lanelets_idx_dict[k]
            for k in sorted(
                neighboring_lanelets_idx_dict,
                key=lambda x: self._lanelet_id_to_index[x],
            )
        ]

    def _compute_center_line_info(self, center_line):
        """Compute additional information about the center line."""
        center_line_vec = torch.diff(
            center_line, dim=0
        )  # Vectors connecting each pair of neighboring points on the center line
        center_line_vec_length = torch.norm(
            center_line_vec, dim=1
        )  # The lengths of the vectors
        center_line_vec_mean_length = torch.mean(
            center_line_vec_length
        )  # The mean length of the vectors
        center_line_vec_normalized = center_line_vec / center_line_vec_length.unsqueeze(
            1
        )

        center_line_yaw = torch.atan2(center_line_vec[:, 1], center_line_vec[:, 0])

        return center_line_yaw, center_line_vec_normalized, center_line_vec_mean_length

    def _compute_boundaries(self, center_line):
        """Compute left and right boundaries of the given center line."""

        def normalize(v):
            norm = torch.norm(v)
            return v if norm == 0 else v / norm

        left_boundary = []
        right_boundary = []

        for i in range(len(center_line) - 1):
            p1 = center_line[i]
            p2 = center_line[i + 1]
            direction = p2 - p1
            perp_direction = torch.tensor([-direction[1], direction[0]])
            perp_direction = normalize(perp_direction)

            left_boundary.append(p1 + perp_direction * self._width / 2)
            right_boundary.append(p1 - perp_direction * self._width / 2)

        left_boundary.append(center_line[-1] + perp_direction * self._width / 2)
        right_boundary.append(center_line[-1] - perp_direction * self._width / 2)

        return torch.stack(left_boundary), torch.stack(right_boundary)

    def _visualize_map(self):
        """
        Visualize the map.
        """

        # Collect all x and y coordinates to determine limits
        all_x = []
        all_y = []

        for path in self.reference_paths:
            center_line = path["center_line"]
            left_boundary = path["left_boundary"]
            right_boundary = path["right_boundary"]

            all_x.extend(center_line[:, 0].tolist())
            all_y.extend(center_line[:, 1].tolist())
            all_x.extend(left_boundary[:, 0].tolist())
            all_y.extend(left_boundary[:, 1].tolist())
            all_x.extend(right_boundary[:, 0].tolist())
            all_y.extend(right_boundary[:, 1].tolist())

        # Determine limits
        x_lim_min = min(all_x)
        x_lim_max = max(all_x)
        y_lim_min = min(all_y)
        y_lim_max = max(all_y)

        print(f"x_lim_min: {x_lim_min} m")
        print(f"x_lim_max: {x_lim_max} m")
        print(f"y_lim_min: {y_lim_min} m")
        print(f"y_lim_max: {y_lim_max} m")

        print(
            f"x_world_dim: {x_lim_max + x_lim_min}"
        )  # A workaround because VMAS assumes (0, 0) is the origin of the map
        print(f"y_world_dim: {y_lim_max + y_lim_min}")

        # Set up the plot
        aspect_ratio = (y_lim_max - y_lim_min) / (x_lim_max - x_lim_min)
        figsize_x = SCENARIOS[self._scenario_type]["figsize_x"]
        fig, ax = plt.subplots(figsize=(figsize_x, figsize_x * aspect_ratio))
        ax.set_aspect("equal", adjustable="box")  # Ensures equal scaling
        ax.grid(True, linewidth=0.3)

        for path in self.reference_paths:
            center_line = path["center_line"]
            left_boundary = path["left_boundary"]
            right_boundary = path["right_boundary"]
            center_line_vec_normalized = path["center_line_vec_normalized"]

            ax.plot(
                center_line[:, 0],
                center_line[:, 1],
                color=Color.black50,
                linestyle="--",
                linewidth=self._linewidth,
                label="Center Line",
                zorder=1,
            )
            ax.plot(
                left_boundary[:, 0],
                left_boundary[:, 1],
                color=Color.black50,
                linestyle="-",
                linewidth=self._linewidth,
                label="Left Boundary",
                zorder=1,
            )
            ax.plot(
                right_boundary[:, 0],
                right_boundary[:, 1],
                color=Color.black50,
                linestyle="-",
                linewidth=self._linewidth,
                label="Right Boundary",
                zorder=1,
            )

            # Fill the area between boundaries
            curve_close = torch.vstack([left_boundary, right_boundary.flip(0)])
            # ax.fill(curve_close[:,0], curve_close[:,1], color="lightgrey", alpha=0.4)

            # Add arrows to indicate direction
            p_start = center_line[0]
            direction_start = center_line_vec_normalized[0]
            ax.quiver(
                p_start[0],
                p_start[1],
                direction_start[0],
                direction_start[1],
                angles="xy",
                scale_units="xy",
                scale=3,
                color="black",
                zorder=2,
            )

            # Calculate the starting point for the ending arrow
            p_end = center_line[-1]
            direction_end = center_line_vec_normalized[-1]
            arrow_length = 0.3  # Adjust here for your case
            # Starting point for the ending arrow such that it ends at the last point
            p_end_start = p_end - direction_end * arrow_length
            # ax.quiver(p_end_start[0], p_end_start[1], direction_end[0], direction_end[1], angles='xy', scale_units='xy', scale=1.5, color='b', alpha=0.2, zorder=2)

            if self._is_visu_lane_ids:
                ax.text(
                    center_line[int(len(center_line) / 2), 0],
                    center_line[int(len(center_line) / 2), 1],
                    str(path["lanelet_IDs"]),
                    fontsize=self._fontsize,
                    zorder=2,
                )

            # ax.set_xlabel(r'$x$ [m]')
            # ax.set_ylabel(r'$y$ [m]')

            offset = 0.05
            ax.set_xlim(x_lim_min - offset, x_lim_max + offset)
            ax.set_ylim(y_lim_min - offset, y_lim_max + offset)
        # plt.title(self._fig_title, fontsize=self._fontsize)

        if self._is_visualize_random_agents:
            n_agents = SCENARIOS[self._scenario_type]["n_agents"]
            self._visualize_random_agents(ax, self.reference_paths, n_agents)

        # Use MaxNLocator to ensure ticks are at readable intervals
        # ax = plt.gca()
        # ax.xaxis.set_major_locator(MaxNLocator(integer=False, prune='both', nbins='auto'))
        # ax.yaxis.set_major_locator(MaxNLocator(integer=False, prune='both', nbins='auto'))
        ax.set_xticks([])
        ax.set_yticks([])

        # Remove the outer box
        for spine in ax.spines.values():
            spine.set_visible(False)

        if self._is_save_fig:
            # Save fig
            plt.tight_layout()  # Set the layout to be tight to minimize white space
            plt.savefig(self._scenario_type + ".pdf", format="pdf", bbox_inches="tight")
            print(f"A fig is saved at {self._scenario_type + '.pdf'}")

        if self._is_plt_show:
            plt.show()


if __name__ == "__main__":
    parser = ParseOSM(
        scenario_type="intersection_2",  # intersection_1, intersection_2, intersection_3, on_ramp_1, roundabout_1
        width=0.15,  # [m]
        scale=1e5,
        device="cpu" if not torch.cuda.is_available() else "cuda:0",
        is_share_lanelets=False,
        is_visualize_map=True,
        is_visualize_random_agents=True,
        is_save_fig=True,
        is_plt_show=True,
        is_visu_lane_ids=False,
    )

    # print(parser.lanelets_all)
    # print(parser.reference_paths)
